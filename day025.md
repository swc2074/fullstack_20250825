## Track001 -  github
 


# ■ Github   
### 12. 깃허브 협업 
---
1. html + css + js/jquery      [개인]
2. spring + mybatis + jstl     
3. node + react
4. spring boot + thymeleaf + jpa + mybatis + react  
5. flutter + spring boot + jpa + mybatis + react





# ■ JAVA
# ■ Java 복습문제
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Q1. 클래스와 인스턴스의 관계를 설명하시오    
클래스는 객체를 만들기 위한 (①   설계도  ) 역할을 한다.
인스턴스는 클래스의 구조를 기반으로 (②   실체화  ) 되어 메모리에 생성된 실체이다.
같은 클래스라도 인스턴스는 서로 다른 (③  특징   ) 값을 가질 수 있다.

Q2. 다음 코드의 실행 결과와 메모리 구조를 설명하시오
```java
Car myCar = new Car("Hyundai", 2023);
```
new Car(...)는 객체를 생성하고 (④  heap   ) 영역에 저장된다.
myCar는 해당 객체의 (⑤  주소    ) 를 참조한다.
생성자 내부에서는 전달받은 값을 (⑥ 초기화    ) 한다.

Q3. 생성자에 대한 설명으로 옳은 것을 고르시오
생성자는 클래스명과 (⑦ 이름    ) 이 같아야 한다.
생성자는 객체 생성 시 자동으로 (⑧  호출   ) 된다.
생성자는 반환값이 (⑨  없다   )

Q4. 기본 생성자가 자동으로 생성되지 않는 경우는?
클래스에 (⑩  오버로딩 된   ) 생성자가 이미 정의되어 있을 경우
상속받은 클래스에서 부모 생성자 호출이 필요한 경우

Q5. 다음 코드에서 객체가 저장되는 메모리 영역과 메서드 실행 흐름을 설명하시오
```java
Book b1 = new Book("Java", 500);
Book b2 = new Book();
b2.setTitle("Spring");
```
Book 클래스의 인스턴스는 (⑪   heap  ) 영역에 저장된다.
b1, b2는 각각 객체의 (⑫   주소  ) 를 참조한다.
setTitle() 메서드는 (⑬  stack   ) 영역에서 실행된다.

Q6. 자바 메모리 구조에서 각 영역의 역할을 설명하시오
Method Area : 클래스 정보 및 static 변수 저장
Heap Area : (⑭    인스턴스 객체 ) 저장, GC가 관리
Stack Area : (⑮    지역변수 및 메서드작업공간 ) 저장, 메서드 호출 시 사용됨

Q7. 변수의 종류와 메모리 위치를 연결하시오
클래스 변수 → (⑯   method area  ) 영역
인스턴스 변수 → (⑰   heap area  ) 영역
지역 변수 → (⑱  stack area   ) 영역

Q8. 접근자를 넓은 범위에서 좁은 범위로 적으시오
(⑲  public   → ⑳   protected → ㉑   default → ㉒ private )

Q9. 다음을 private으로 설정했다. 외부에서 접근 가능하게 설정해야 하는 것
(㉓  getter / ㉔  setter ) 이다. 





# ■ Java 진행 (1)
>>>>>>>>>>>>>>>>>>>>>>  
 
● 5. 클래스배열
  클래스[]  배열명 = new 클래스[갯수];
  
  String[]   arr     = new String[3];  
  A1     []   carr   = new A1[3];  // [null, null, null ]
  ※ null  - 공간은 있지만 값이 비어있어!
   
  carr[0]  = new  A1();  ※ 생성자를 불러서 인스턴스변수를 초기화해 사용가능하게만들기
  1번지{  name="" }  ←  carr[0] 1번지




연습문제1)  클래스배열
패키지명 : com.company.java011_ex
클래스명 : ClassArrEx1
다음과 같이 코드를 작성하시오.
ㅁ출력된 화면
Apple [name=RED, order=iron, num=2, price=1000]
Apple [name=GREEN, order=hulk, num=1, price=1500]
Apple [name=GOLD, order=captain, num=3, price=2000]

ㅁ주어진 옵션
public class Apple{   //// 실행 main과 파일을 분리해주세요!
   private String name;
   private String order;
   private int num;
   private int price;
}

public class ClassArrEx1{
  public static void main(String[] args) {
        Apple[] apples= new Apple[3]; 
        //위의 화면처럼 값 셋팅
        //위의 화면처럼 출력
  }
}





연습문제2)  클래스배열
패키지명 : com.company.java011_ex
클래스명 : ClassArrEx2
다음과 같이 코드를 작성하시오.
ㅁ출력된 화면
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
이름	국어	영어	수학	평균	합격여부
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
아이언맨	100	100	100	100.0	합격
헐크	90	60	80	76.0	합격
블랙팬서	20	60	90	56.0	불합격

ㅁ주어진 옵션
public class  Score2{   //// 실행 main과 파일을 분리해주세요!
	private String name;   // 셋팅 setName() ,가져오기 getName()
	private int kor, eng, math;  // setKor , getKor /  setEng , getEng / setMath , getMath
	private double avg;
	private String pass;
}
public class ClassArrEx2 {
  public static void main(String[] args) {
	////// MODEL
	Score2[] std = new Score[3];  
	// 0번째에는 아이언맨 정보넣기  - "아이언맨", 100, 100, 100
	// 1번째에는 아이언맨 정보넣기  - "헐크", 90, 60, 80
	// 2번째에는 아이언맨 정보넣기  - "블랙팬서", 20, 60, 90
		
	////// CONTROLLER - 처리 해결사 Controller)
	Score2Process process = new Score2Process();
	process.process_avg(std); 
	process.process_pass(std); 
	process.process_pass(std);  
	
	////// VIEW       - CONSOLE , WEB
	Score2Print  print = new Score2Print();
	print.show(std);  
  }
}
 
 
● 6. 클래스다이어그램
1. 시스템을 구성하는 클래스들 사이관계를 표현
2. 클래스 - 객체를 생성하는 설계도
3. staruml.io - 다운로드 - 설치
4. 클래스
---------------------
[Animal]
---------------------
add - attribute (멤버변수)
---------------------
add - operation (멤버함수)
---------------------

5. uml 관계
>1) 연관관계  ( 연결  →  , 한쪽은 알지만, 다른쪽은 상대방의 존재는 모름 )
>2) 일반화관계(상속, IS-A 고양이는 동물이다, 속이 빈 화살표  )
     고양이는 동물이다(O) , 사람도 동물이다(O) , 동물은 고양이다? (x)   
> 3) 집합관계 (자동차 = 엔진 + 휠
              ◆  생성자안에서 new (합성)   , ◇ 생성자 안에서 주소(집약) )
4) 의존관계
5) 실체화관계(인터페이스)

6. SOLID 원칙
S : 단일책임      - 한 클래스는 한가지 일만해요. (쿠키굽기)
O : 개방폐쇄      - 새로운 쿠키는 쉽게 추가 (확장o, 수정x) 
L : 리스코프치환   - 모든쿠키는 같은방식으로 만들수 있어요!  
I : 인터페이스분리 - 필요한 기능만 딱! 인터페이스 나누기 
D : 의존역전      - 구체적인 쿠키말고, 추상적인 쿠키에 의존




● 7. 상속
1. 상속?  클래스의 재사용 - 새로운 부분만 추가, 수정해서 사용

2. super  vs  sub
  부모           자식
  상위           하위
  parent        child
  super         sub

3. 모든클래스는 Object 클래스를 상속

4. UML - 부모 ← 자식

5. 장점 - 빠른개발, 코드의 중복성제거, 다형성(하나의 타입으로 여러타입을 관리)

6. 문법
  class  자식클래스 extends 부모클래스  (O)  단일상속
  
  class  자식클래스 extends 부모클래스1, 부모클래스2 (X)

7. 상속시 부모속성을 사용할수 있는 이유?
   - 부모생성자를 호출해 
     부모의 인스턴스변수를 초기화해 사용가능하게 만들어줌.

8. 오버라이드
  - @Override
  - 상속(extends)시  부모의 메서드와 동일한지


연습문제1)  멤버변수
패키지명 : com.company.java011_ex
클래스명 :   ExtendsEx001.java
1. 아래 조건에 맞게 Extends002.java 파일을 작성하고, main() 메서드를 수정하여 다음과 같은 출력 결과가 나오도록 하시오.
2. 주어진 코드 (수정 전)
```java
public class ExtendsEx001 {
    public static void main(String[] args){
        Green mygreen = new Green();
        mygreen.name = "LIGHT_GREEN";
        mygreen.num = 5;
        mygreen.show();
    }
}
```
3.출력 결과 
GREEN
NAME : LIGHT_GREEN
NUM : 5

4. 클래스 구조 설명
 Color 클래스 : 멤버 변수:  name (String, public)  / num (int, private)
  ↑
Green 클래스   
 

5 요구사항
1) Color와 Green 클래스의 상속 관계를 활용할 것
2) main() 메서드에서 직접 name과 num에 값을 할당할 수 있도록 접근 제어자를 고려할 것
3) show() 메서드를 통해 출력 형식을 맞출 것



연습문제2)     클래스 상속과 메서드 오버라이딩
패키지명 : com.company.java011_ex 
클래스명 : ClassEx002.java

1. 아래 조건에 맞게 ClassEx002.java 파일을 작성하고,
   main() 메서드를 수정하여 다음과 같은 출력 결과가 나오도록 하시오.
2. 주어진 코드 (수정 전)
```java
public class ClassEx002 {
    public static void main(String[] args) {
        MobileNote7 my7 = new MobileNote7();
        my7.setIris("brown");
        my7.setFace("pretty");
        my7.newShow();

        MobileNote8 my8 = new MobileNote8();
        my8.setFace("pretty");
        my8.newShow();

        MobileNote9 my9 = new MobileNote9();
        my9.setBattery(24);
        my9.newShow();
    }
}
```
3. 출력 결과 

NOTE7 객체 기능(Overriding)
iris = brown
face = pretty

NOTE8 객체 기능(Overriding) 추가
face = pretty

NOTE9 객체 기능(Overriding) 추가
battery 예쁘게 사용하기!
battery = 24

4. 클래스 구조 설명
클래스명      멤버변수        멤버메서드
MobileNote   없음                        void show()
MobileNote7   String iris, String face  void newShow()
MobileNote8   String face                 void newShow()
MobileNote9   int battery                 void newShow()
모든 멤버변수는 private으로 선언

-각 클래스는 MobileNote 클래스를 상속받음
-newShow() 메서드는 각 클래스에서 오버라이딩되어 고유한 출력 형식을 가짐

5. 요구사항
-MobileNote 클래스를 기반으로 상속 구조를 설계할 것 (MobileNote7, MobileNote8, MobileNote9 모두 상속)
-각 클래스에서 setter 메서드를 통해 멤버변수 값을 설정할 수 있도록 구현할 것
-newShow() 메서드를 오버라이딩하여 출력 형식을 문제에서 제시한 형태로 맞출 것
-출력 순서와 내용이 정확히 일치하도록 main() 메서드를 구성할 것



연습문제3)    클래스 상속과 메서드 호출 우선순위
패키지명 : com.company.java011_ex 
클래스명 : ClassEx003.java

1. 아래 조건에 맞게 ClassEx003.java 파일을 작성하고, 
   빈칸을 채운 뒤 main() 메서드를 실행하여 출력 결과를 예상하시오.
2. 주어진 코드 (수정 전)
```java
class Grand extends Object {
    public void one() { System.out.println("grand : one"); }
    public void two() { System.out.println("grand : two"); }
}
// (1) Father 클래스가 Grand 클래스를 상속받도록 수정
public class Father {
    public void three() { System.out.println("Father : three"); }
}

```
3. 출력 결과  
 
grand : one
grand : two
Father : three

4. 클래스 구조 설명
클래스명        상속 관계       주요 메서드
1) Object   최상위 클래스           -
2) Grand      Object → Grand         one(), two()
3) Father   Grand → Father       three()
4) Uncle      Object → Uncle 
5) Aunt      Object → Aunt     
- 모든 클래스는 Object 클래스를 기본적으로 상속받음
- Grand 클래스는 one()과 two() 메서드를 정의
- Father 클래스는 Grand를 상속받아 three() 메서드를 추가

5. 요구사항
- Father 클래스가 Grand 클래스를 상속받도록 extends 키워드를 활용할 것
- main() 메서드에서 Father 객체를 생성하고 one(), two(), three() 메서드를 순서대로 호출할 것
- 상속 관계에 따라 메서드 호출 우선순위를 이해하고 출력 결과를 정확히 예측할 것
- Uncle, Aunt 클래스도 Object를 상속받는 구조로 확장 가능하므로, 필요 시 추가 구현할 것







# ■ JAVA
# ■ JAVA 복습문제
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 
Q1. 다음과 같이 코드를 작성하시오.

public class ClassArrEx1{
  public static void main(String[] args) {
        Apple[] apples= new Apple[3]; 
        // 화면처럼 값 셋팅
        // 화면처럼 출력
  }
}

ㅁ출력된 화면
Apple [name=RED, order=iron, num=2, price=1000]
Apple [name=GREEN, order=hulk, num=1, price=1500]
Apple [name=GOLD, order=captain, num=3, price=2000]

```java
     
        
        Apple[] apples= new Apple[] { 
        		new Apple("RED" , "iron" , 2 , 1000) ,  new Apple("GREEN" , "hulk" , 1 , 1500)
        		,new Apple("GOLD" , "captain" , 3 , 2000)
        };

      for( Apple   a  :  apples ) { System.out.println(a);  }
```




Q2. 상속도를 달고 다음에 답변을 달으시오.   

 class Grand extends Object {
    public void one() { System.out.println("Grand : one"); }
    public void two() { System.out.println("Grand : two"); }
}
class Father extends Grand {
    public void three() { System.out.println("Father : three"); }
}
class Uncle extends Grand{
    public void four(){ System.out.println("Uncle : four"); }
    @Override public void one() { System.out.println("Uncle : one"); }  ##
    @Override public void two() { System.out.println("Uncle : two"); }  ##
}
 
public class ClassEx003 {
	public static void main(String[] args) {
		Father papa  = new Father(); papa.one();   papa.two();  papa.three();
		Uncle  uncle = new Uncle(); uncle.four();  uncle.one();  uncle.two();  
		//Q1. uncle이 쓸수 있는 메서드는?      
		//Q2. 24번째줄에서 출력되는 내용은?   
		//Q3.  개념은?  
	}
}

```
		//Q1. uncle이 쓸수 있는 메서드는?      Uncle { one() ,two() ,four()  } →   Grand{ one() ,two()  }
		//Q2. 24번째줄에서 출력되는 내용은?   Uncle { @one() ,@two() ,four()  } →   Grand{ one() ,two()  }
		//Q3.  개념은? 오버라이딩: 상속시 부모와 같은 메서드를 자식클래스에 맞게 수정한것!
```
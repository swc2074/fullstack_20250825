## Track001 -  github

 
# ■ Github   
### 12. 깃허브 협업 
---
1. html + css + js/jquery      [개인]
2. spring + mybatis + jstl     
3. node + react
4. spring boot + thymeleaf + jpa + mybatis + react  
5. flutter + spring boot + jpa + mybatis + react
 


# ■ JAVA
# ■ Java 복습문제
■ 복습문제  (~09:40)
//Q1. 상속도를 그리시오. 
/*
     Object
       ↑	
    TestA4   {  a=10;    --------   }
       ↑
    TestB4   {  b=20;  @toString } 
*/

class TestA4  extends Object{  
   int a=10;
   @Override public String toString() { return "TestA4 [a=" + a + "]"; }
}
class TestB4  extends TestA4{  
   int b=20;
   @Override public String toString() { return "TestB4 [b=" + b + "]"; }
}
/////////////////////////////////////////////////
public class PolyEx003 {
   public static void main(String[] args) { 
      -----------------------------------
      TestA4  ta = new TestA4();
      -----------------------------------
      //Q2. TestA4  ta 사용할수 있는범위는?    {  a=10;   toString } 
      //Q3. new TestA4() 는  heap area 에서 호출되는 생성자의 순서와 객체가 만들어지는 순서는?
	생성자 :  TestA4()                 → Object()  / 객체가 만들어지는 순서 : Object → TestA4 

      -----------------------------------
      TestB4  tb = new TestB4();  
      -----------------------------------
      //Q4. TestB4  tb 사용할수 있는범위는?
                {  b=20;  @toString }   →  {  a=10;   --------  } 
      //Q5. new TestB4() 는  heap area 에서 호출되는 생성자의 순서와 객체가 만들어지는 순서는?
                생성자 : TestB4()   →  TestA4()  → Object()  / 객체가 만들어지는 순서 : Object → TestA4  →  TestB4	   
                            {} → {  a=10;  -------  }   →{  b=20;  @toString }

      //Q6. ta가 사용할수 있는 보장하는 변수와 메서드는?   {  a=10;   toString } 

      //Q7.ta = new TestB4(); 에서 new TestB4() 에서 사용할수 있는 범위는? 
        7-1. ta :    {  a=10;   toString }  쓸수있게해줄께요... 일단 쓰지않음.
       > 7-2. new TestB4();    3000번지  실제 인스턴스화 :   TestB4{  b=20;  [ @toString } -   TestA4{  a=10;  ]  -------  } 
        7-3.  ta(3000번지) =  3000번지  {  b=20;  [@toString } -   {  a=10;]  -------  } 

      -----------------------------------
      	tb         = (TestB4) ta;   
      -----------------------------------       
      //Q8. tb         = (TestB4) ta;   에서 tb가 사용할수 있는 범위는?
          8-1. tb : {  b=20;  @toString }   →  {  a=10;   --------  } 
          8-2.  ta =  3000번지  {  b=20;  [@toString } -   {  a=10;]  -------  } 
          8-3. 타입캐스팅  tb= [{  b=20;  @toString } -   {  a=10;]  -------  } 

      //Q9. 컴피일러시  tb         = (TestB4) ta;  오류가 안나는 이유는?     ta = new TestB4();  
            ta가 사용할수 있는거는 a=10, toString 이었는데,,,,,, 자식생성자를 호출해서 b=20, toString 처리해서 
      System.out.println(tb);  //Q10. 출력내용과 그이유는?   TestB4   본인꺼
      System.out.println(tb.b);//Q11. 출력내용?   20    본인꺼
      System.out.println(tb.a);//Q12. 출력내용?   10    부모꺼
      
   }
} 


1.  다형성
- 많은 형상을 띄는 성품
- 여러타입의 객체(자식객체)를 하나의 타입(부모)으로 관리

2. 부모는 자식을 담을 수 있다.  (업캐스팅)
----------------------------------
Animal  [name, age / 먹기, 자기, 배변]  
  ↑
 Cat     [card / 꾹꾹]
----------------------------------
Animal  ani = new Cat();        부모 = 자식      고양이는 동물이다

2-1)   Animal  ani { name, age / 먹기, 자기, 배변} 
2-2)   Cat() → Animal() → Object()
       {card / 꾹꾹} + {name, age / 먹기, 자기, 배변} 


3. 자식은 부모를 담을 수 있다.  (다운캐스팅) 
Cat     cat = new Animal()      자식 = 부모       동물은 고양이이다.

3-1)   Cat     cat;        
     {card / 꾹꾹} + {name, age / 먹기, 자기, 배변} 
3-2)   new Animal()    
                          {name, age / 먹기, 자기, 배변} 
3-3) 만족못시키는 범위 생김
     {card / 꾹꾹}
> 3-4)  해결방안
    ..... 부모타입에서 자식생성자를 호출한 적이 있으면 사용가능.
    Animal ani = new Cat();              3000번지 {card / 꾹꾹} + [{name, age / 먹기, 자기, 배변}] 
	자식생성자를 호출해서 자식의 범위를 쓸수 있게 만들었으므로 
    Cat     cat = (Cat)ani
	부모객체에서 자식타입으로 [타입캐스팅]이 필요함
	 cat(3000번지) =3000번지 [   {card / 꾹꾹} + {name, age / 먹기, 자기, 배변}  ] 
     

● 9. abstract         
1. 추상화
 -  실체화된 객체들 간에 공통되는 특성을 추출
 -  미완성적인 개념 (  new 사용하지 못함  )
 -  공통된 필드와 메서드의 이름을 통일할 목적

2. 추상클래스
-----------------------------------------------
abstract  class Animal{
   String name;               //인스턴스변수 - this - 각각
   abstract  void sound();  // abstract method();        -  {} 구현부가 없음
}
class Cat   extends Animal{  @override  void sound(){   야옹  } }
class Dog  extends Animal{  @override  void sound(){   멍멍  } }
-----------------------------------------------     




● 10. interface
1.  interface  
   - 개발코드변경없이 객체를 바꿔낄수 있도록 하는 역할

2.  abstract ( Is A : 고양이는 동물이다 ) vs  interface( can do this )
   - 추상화 정도가 interface가 도 높다.
   1) abstract  - 인스턴스변수                  , 일반메서드, 추상메서드(abstract) 가질수 있음.
   2) interface - 상수(public static final)   + 추상메서드(public abstract) 만 가짐.

3. 프로젝트 진행시 interface 사용
    다른구성원들이 각각의 부분을 완성할때까지 기다리지 않고
    규약만 정해두만 본인 부분만 작성.

4. interface 형식
------------------------------------------------------
  interface 인터페이스명{
     상수;      // public static final
     추상메서드; // public abstract    {} X - this X
  }
------------------------------------------------------
class  interSon    implements 인터페이스명{}
class  interSon2  extends 클래스명 implements 인터페이스1, 인터페이스2{}

 


# ■ WEB BASIC


# ■ JAVA
# ■ JAVA 복습문제
Q1. 다음의 상속도를 그리시오.
Q2. 상속도에서  각각의 클래스에서 사용가능한 멤버변수/멤버함수를  적으시오.

abstract class Animal{    
	String name; 
	abstract void eat();   
	abstract void sleep(); 
	abstract void poo();  
}
class Cat  extends Animal{  // 구현클래스 - 고양이는 동물이다
	@Override void eat()   {  System.out.println(super.name + "고양이 냠냠!");  }
	@Override void sleep() {  System.out.println(super.name + "고양이 수면!");  }
	@Override void poo()   {  System.out.println(super.name + "고양이 시원");  }
}
class Dog  extends Animal{  // 구현클래스 - 강아지는 동물이다
	@Override void eat()   {  System.out.println(super.name + "강아지 냠냠!");  }
	@Override void sleep() {  System.out.println(super.name + "강아지 수면!");  }
	@Override void poo()   {  System.out.println(super.name + "강아지 시원");  }
}
public class Abstract001 {
	public static void main(String[] args) {
		//1. abstract  class : 일반클래스 + 설계
		Animal ani = new Animal();   Q3. 이코드에서 오류나는 이유는? 
	 
		Animal ani = null;
		ani = new Cat();   //Q4. 다형성에서 다음을 뭐라하는가?   업캐스팅/다운캐스팅? , 타입캐스팅 필요여부
		ani.name = "sally";   ani.eat();
 
		
		//2. 사용목적
		Animal [] arr = {new Cat() , new Cat() , new Dog() , new Dog() , };
		int cnt=0;
		//Q5.  다음이 출력되게 코드를 작성하시오.
		/*ani1고양이 냠냠!
		  ani2고양이 냠냠!
		  ani3강아지 냠냠!
		 ani4강아지 냠냠!   */
	}
}


>>>>>>>>>>>>>>>>> Answer
```
/* Q1,Q2
	    Object  
      	↑
	     Animal {name / eat(), sleep(), poo() }
	     ↑   ↑ 
	    Cat  Dog  { @eat(), @sleep(), @poo() }
*/

abstract class Animal{   //일반클래스 + 설계
	String name; 
	abstract void eat();  // 추상메서드가 있으면 반드시 추상클래스로 만들어줘야함.
	abstract void sleep();// 구현부가 없음 {}
	abstract void poo();  // 추상화, 일반화, 설계: 공통의 속성, 구체적인 내용이 없음
}
class Cat  extends Animal{  // 구현클래스 - 고양이는 동물이다
	@Override void eat()   {  System.out.println(super.name + "고양이 냠냠!");  }
	@Override void sleep() {  System.out.println(super.name + "고양이 수면!");  }
	@Override void poo()   {  System.out.println(super.name + "고양이 시원");  }
}
class Dog  extends Animal{  // 구현클래스 - 강아지는 동물이다
	@Override void eat()   {  System.out.println(super.name + "강아지 냠냠!");  }
	@Override void sleep() {  System.out.println(super.name + "강아지 수면!");  }
	@Override void poo()   {  System.out.println(super.name + "강아지 시원");  }
}
public class Abstract001 {
	public static void main(String[] args) {
		//1. abstract  class : 일반클래스 + 설계
		// Animal ani = new Animal();   Q3 new 메모리빌리고,객체생성/ Animal()초기화, {}구현부없음
		// 
		Animal ani = null;
		ani = new Cat();   // Q4. 부모 = 자식 , 업캐스팅, 타입캐스팅 필요없음
		ani.name = "sally";   ani.eat();

		ani = new Dog();   // 부모 = 자식 , 업캐스팅, 타입캐스팅 필요없음
		ani.name = "alpha";   ani.eat();
		
		//2. 사용목적
		Animal [] arr = {new Cat() , new Cat() , new Dog() , new Dog() , };
		int cnt=0;
		//Q5
      for(Animal a :  arr) {  a.name = "ani" + ++cnt;  a.eat();  }
	}
} 
```


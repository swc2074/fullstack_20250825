## Track001 -  github

 
# ■ Github   
### 12. 깃허브 협업 
---
1. html + css + js/jquery      [개인]
2. spring + mybatis + jstl     
3. node + react
4. spring boot + thymeleaf + jpa + mybatis + react  
5. flutter + spring boot + jpa + mybatis + react
 


# ■ JAVA
# ■ Java 복습문제
■ 복습문제  (~09:40)
//Q1. 상속도를 그리시오. 
/*
     Object
       ↑	
    TestA4   {  a=10;    --------   }
       ↑
    TestB4   {  b=20;  @toString } 
*/

class TestA4  extends Object{  
   int a=10;
   @Override public String toString() { return "TestA4 [a=" + a + "]"; }
}
class TestB4  extends TestA4{  
   int b=20;
   @Override public String toString() { return "TestB4 [b=" + b + "]"; }
}
/////////////////////////////////////////////////
public class PolyEx003 {
   public static void main(String[] args) { 
      -----------------------------------
      TestA4  ta = new TestA4();
      -----------------------------------
      //Q2. TestA4  ta 사용할수 있는범위는?    {  a=10;   toString } 
      //Q3. new TestA4() 는  heap area 에서 호출되는 생성자의 순서와 객체가 만들어지는 순서는?
	생성자 :  TestA4()                 → Object()  / 객체가 만들어지는 순서 : Object → TestA4 

      -----------------------------------
      TestB4  tb = new TestB4();  
      -----------------------------------
      //Q4. TestB4  tb 사용할수 있는범위는?
                {  b=20;  @toString }   →  {  a=10;   --------  } 
      //Q5. new TestB4() 는  heap area 에서 호출되는 생성자의 순서와 객체가 만들어지는 순서는?
                생성자 : TestB4()   →  TestA4()  → Object()  / 객체가 만들어지는 순서 : Object → TestA4  →  TestB4	   
                            {} → {  a=10;  -------  }   →{  b=20;  @toString }

      //Q6. ta가 사용할수 있는 보장하는 변수와 메서드는?   {  a=10;   toString } 

      //Q7.ta = new TestB4(); 에서 new TestB4() 에서 사용할수 있는 범위는? 
        7-1. ta :    {  a=10;   toString }  쓸수있게해줄께요... 일단 쓰지않음.
       > 7-2. new TestB4();    3000번지  실제 인스턴스화 :   TestB4{  b=20;  [ @toString } -   TestA4{  a=10;  ]  -------  } 
        7-3.  ta(3000번지) =  3000번지  {  b=20;  [@toString } -   {  a=10;]  -------  } 

      -----------------------------------
      	tb         = (TestB4) ta;   
      -----------------------------------       
      //Q8. tb         = (TestB4) ta;   에서 tb가 사용할수 있는 범위는?
          8-1. tb : {  b=20;  @toString }   →  {  a=10;   --------  } 
          8-2.  ta =  3000번지  {  b=20;  [@toString } -   {  a=10;]  -------  } 
          8-3. 타입캐스팅  tb= [{  b=20;  @toString } -   {  a=10;]  -------  } 

      //Q9. 컴피일러시  tb         = (TestB4) ta;  오류가 안나는 이유는?     ta = new TestB4();  
            ta가 사용할수 있는거는 a=10, toString 이었는데,,,,,, 자식생성자를 호출해서 b=20, toString 처리해서 
      System.out.println(tb);  //Q10. 출력내용과 그이유는?   TestB4   본인꺼
      System.out.println(tb.b);//Q11. 출력내용?   20    본인꺼
      System.out.println(tb.a);//Q12. 출력내용?   10    부모꺼
      
   }
} 


1.  다형성
- 많은 형상을 띄는 성품
- 여러타입의 객체(자식객체)를 하나의 타입(부모)으로 관리

2. 부모는 자식을 담을 수 있다.  (업캐스팅)
----------------------------------
Animal  [name, age / 먹기, 자기, 배변]  
  ↑
 Cat     [card / 꾹꾹]
----------------------------------
Animal  ani = new Cat();        부모 = 자식      고양이는 동물이다

2-1)   Animal  ani { name, age / 먹기, 자기, 배변} 
2-2)   Cat() → Animal() → Object()
       {card / 꾹꾹} + {name, age / 먹기, 자기, 배변} 


3. 자식은 부모를 담을 수 있다.  (다운캐스팅) 
Cat     cat = new Animal()      자식 = 부모       동물은 고양이이다.

3-1)   Cat     cat;        
     {card / 꾹꾹} + {name, age / 먹기, 자기, 배변} 
3-2)   new Animal()    
                          {name, age / 먹기, 자기, 배변} 
3-3) 만족못시키는 범위 생김
     {card / 꾹꾹}
> 3-4)  해결방안
    ..... 부모타입에서 자식생성자를 호출한 적이 있으면 사용가능.
    Animal ani = new Cat();              3000번지 {card / 꾹꾹} + [{name, age / 먹기, 자기, 배변}] 
	자식생성자를 호출해서 자식의 범위를 쓸수 있게 만들었으므로 
    Cat     cat = (Cat)ani
	부모객체에서 자식타입으로 [타입캐스팅]이 필요함
	 cat(3000번지) =3000번지 [   {card / 꾹꾹} + {name, age / 먹기, 자기, 배변}  ] 
     

● 9. abstract         
1. 추상화
 -  실체화된 객체들 간에 공통되는 특성을 추출
 -  미완성적인 개념 (  new 사용하지 못함  )
 -  공통된 필드와 메서드의 이름을 통일할 목적

2. 추상클래스
-----------------------------------------------
abstract  class Animal{
   String name;               //인스턴스변수 - this - 각각
   abstract  void sound();  // abstract method();        -  {} 구현부가 없음
}
class Cat   extends Animal{  @override  void sound(){   야옹  } }
class Dog  extends Animal{  @override  void sound(){   멍멍  } }
-----------------------------------------------     




● 10. interface
1.  interface  
   - 개발코드변경없이 객체를 바꿔낄수 있도록 하는 역할

2.  abstract ( Is A : 고양이는 동물이다 ) vs  interface( can do this )
   - 추상화 정도가 interface가 도 높다.
   1) abstract  - 인스턴스변수                  , 일반메서드, 추상메서드(abstract) 가질수 있음.
   2) interface - 상수(public static final)   + 추상메서드(public abstract) 만 가짐.

3. 프로젝트 진행시 interface 사용
    다른구성원들이 각각의 부분을 완성할때까지 기다리지 않고
    규약만 정해두만 본인 부분만 작성.

4. interface 형식
------------------------------------------------------
  interface 인터페이스명{
     상수;      // public static final
     추상메서드; // public abstract    {} X - this X
  }
------------------------------------------------------
class  interSon    implements 인터페이스명{}
class  interSon2  extends 클래스명 implements 인터페이스1, 인터페이스2{}

 

연습문제1) 게시판 기능을 인터페이스로 구현하기
패키지명 :  package com.company.java013_ex;
클래스명 :  public class InterfaceEx001

1. 문제 설명
다음은 게시판 기능을 인터페이스로 추상화한 프로그램이다. 
Board 인터페이스는 게시판 기능의 공통 동작을 정의하며, 
BoardInsert, BoardSelect, BoardUpdate, BoardDelete 클래스는 이를 구현하여 각각의 기능을 수행한다.

2. 주어진 조건

interface Board {    void exec();  }

구현 클래스들
BoardInsert: 글쓰기 기능
BoardSelect: 글읽기 기능
BoardUpdate: 글수정 기능
BoardDelete: 글삭제 기능
- 각 클래스는 exec() 메서드를 오버라이딩하여 해당 기능을 출력한다.

3. 메인 클래스 작성 
```
public class InterfaceEx002 {
    public static void main(String[] args) {
        Board controller = null; 
        controller = new BoardInsert();  controller.exec();
        controller = new BoardSelect();  controller.exec();
        controller = new BoardUpdate();  controller.exec();
        controller = new BoardDelete();  controller.exec();
    }
}
```
4.  실행 결과 
글쓰기
글읽기
글수정
글삭제


연습문제2)  
패키지명 :  package com.company.java013_ex;
클래스명 :  public class InterfaceEx002

1. Driver 클래스를 작성하시오.  
2. 주어진조건
interface Vehicle {
	public void run();
} 
class MotorCycle implements Vehicle {
	@Override
	public void run() {
		System.out.println("오토바이가 달립니다.");
	}
}
class Car implements Vehicle {
	@Override
	public void run() {
		System.out.println("자동차가 달립니다.");
	}
}

3. 메인화면
public class Oop014_method_polymorphism {
	public static void main(String[] args) {
		Driver driver = new Driver();
		
		Car car = new Car();
		MotorCycle mo = new MotorCycle();
		
		driver.drive(car);
		driver.drive(mo);
	}
}

4. 실행화면
자동차가 달립니다.
오토바이가 달립니다.




연습문제3)  
패키지명 :  package com.company.java013_ex;
클래스명 :  public class InterfaceEx003

1. 인터페이스를 활용한 점심 주문 시뮬레이션
다음은 점심 메뉴 주문을 인터페이스로 추상화한 프로그램이다. 
Launch 인터페이스는 모든 메뉴가 공통적으로 가져야 할 기능을 정의하며, 
Burger, KimchiStew 클래스는 이를 구현하여 각각의 메뉴 정보를 제공한다. 
User 클래스는 메뉴를 주문하고, 주문 내역을 출력하는 기능을 담당한다.

2. 주어진 조건
interface Launch {
    int MONEY = 10000;
    void eat();
}
class Burger      implements Launch{ 
	int price;
	public Burger() { this.price = 3900; }
	@Override public String toString() { return "Burger"; }
	@Override public void eat() { System.out.println("Burger 냠냠!"); } 
}
class KimchiStew  implements Launch{ 
	int price;
	public KimchiStew() { this.price = 4000; }
	@Override public String toString() { return "KimchiStew"; }
	@Override public void eat() { System.out.println("KimchiStew 냠냠!"); } 
}
class User {  
    int money;
    int cnt;
    Launch[] plate;
- order(Launch a) 메서드로 메뉴 주문
  주문 시 메뉴 종류에 따라 가격 확인
  잔액 부족 시 주문 거절
  주문 성공 시 배열에 저장
- show() 메서드로 주문 내역 출력
  주문한 메뉴 목록
  총 주문 금액
  잔액
  오늘 날짜
  각 메뉴의 eat() 호출
}
3. main
public class InterfaceEx004_Ex {
	public static void main(String[] args) {
		 User launch_order = new User();
		 								     //리턴값 메서드명(파라미터)
		 launch_order.order(new Burger());   //void order(Launch a){}
		 launch_order.order(new KimchiStew());   //Launch a = new Kimchi()  부모=자식
		 launch_order.order(new Burger());   //Launch a = new Burger()  부모=자식
		 									
		 launch_order.show();//리턴값 메서드명(파라미터)
		 				     // void   show(){}
	}
}


4. 실행 예시 
버거하나요~ 
Burger 냠냠!
김치찌개하나요~ 
KimchiStew 냠냠!
버거하나요~ 
Burger 냠냠!


주문 :  Burger, KimchiStew, Burger
주문금액 : 11800
잔액    : -1800
2025년 9월 30일
Burger 냠냠!
KimchiStew 냠냠!
Burger 냠냠!
※ 실제 실행 결과는 날짜 및 주문 순서에 따라 달라질 수 있습니다.










 

# ■ JAVA
# ■ JAVA 복습문제
복습문제1)  [note]  이론  
```
1. interface의 멤버변수는 __(1)__이고, 멤버함수는 __(2)__로 이루어진 설계 클래스이다.
2. abstract와 interface의 차이점은 __(3)__의 정도인데, __(4)__가 더 크다.
3. 콜렉션 프레임워크는 __(5)__의 단점을 보완하고자 나온 __(6)__이다.
4. List의 특징은 __(7)__이 있고, __(8)__이 가능하다.
5. 사용할 수 있는 메서드의 종류는 __(9)__, __(10)__, __(11)__, __(12)__, __(13)__이다.
```

```
1. interface의 멤버변수는 __(1) 상수__이고, 멤버함수는 __(2) 추상메서드__로 이루어진 설계 클래스이다.
2. abstract와 interface의 차이점은 __(3) 추상화__의 정도인데, __(4) interface__가 더 크다.
3. 콜렉션 프레임워크는 __(5) 배열__의 단점을 보완하고자 나온 __(6) 동적배열__이다.
4. List의 특징은 __(7) 순번(index)__이 있고, __(8) 중복허용__이 가능하다.
5. 사용할 수 있는 메서드의 종류는 __(9) add__, __(10) get__, __(11) size__, __(12) remove__, __(13) contains__이다.
```


복습문제2) [note]
Q1. 상속도를 그리시오.
Q2. Driver 클래스를 작성하시오.  
interface Vehicle {
	public void run();
} 
class MotorCycle implements Vehicle {
	@Override
	public void run() {
		System.out.println("오토바이가 달립니다.");
	}
}
class Car implements Vehicle {
	@Override
	public void run() {
		System.out.println("자동차가 달립니다.");
	}
}
public class Oop014_method_polymorphism {
	public static void main(String[] args) {
		Driver driver = new Driver();
		
		Car car = new Car();
		MotorCycle mo = new MotorCycle();
		
		driver.drive(car);   // 자동차가 달립니다.
		driver.drive(mo);  // 오토바이가 달립니다.
	} 
}
 
```
class Driver{   void  drive(Vehicle  v){  v.run();  }  }
```


복습문제3) [eclipse]
클래스명 : Repeat029
다음과 같이 코드를 작성하시오.
 1.  ArrayList이용해서 colors 만들기
 2. red, green, blue 데이터 추가
 3. 출력

```
public class ListEx001 {
	public static void main(String[] args) {
		 List<String> colors = new ArrayList<>();
		 colors.add("red");
		 colors.add("green");
		 colors.add("blue"); 
		 
		 System.out.println( colors); 
	}
}
```







1. merge 직후
```
git log --oneline
git reset --hard 586059e
git push origin master --force
```
 


■ Bank
◎1. 시스템개요
프로젝트명 : Bank Management System
목적 : 사용자 계좌관리 기능을 제공하는 콘솔기반 은행시스템
기능 : 계좌생성, 입금, 출금, 계좌삭제, 로그인
기술스택 : 
- 사용언어 : jAVA 
- 설계패턴 : MVC
- UML 
특징 : 객체지향 원칙준수, 확장성 높은 구조

◎2. 클래스구조 설명
 - MVC(Model , View , Controller)
1. 유저정보모델: <<class>> UserInfo
   - 사용자 계좌정보를 저장하는 데이터 모델
   - String id, String pass, double balance
   - List<UserInfo> users;

2. 기능 : 인터페이스 & 클래스
인터페이스 : 공통동작 정의
  <<  interface >> BankController { exec(ArrayList<UserInfo> users); }

구현클래스
 Login, Add, Deposit, widthdraw, Delete

3. 메인컨트롤러
   <<class>>Bank_Main 
   멤버변수: ArrayList<UserInfo> users , BankController controller
   멤버함수:  menu(), main()

◎3. UML 클래스 다이어그램
 - Bank_Main -> UserInfo  <연관관계>
 - Bank_Main -> BankController  <의존관계>
 - BankController  <- Login, Add, Deposit, widthdraw, Delete  < 실체화 관계 >

<<interface>> BankController
...     ... ....       ...        ...
Login, Add, Deposite, widthdraw, Delete



Bank_Main  -> UserInfo <연관관계>  실선화살표  - 멤버변수로 포함
Bank_Main  -> BankController <의존관계> 점선화살표 - 인터페이스를 일시적으로 사용, 
                                                                  Login, Add 교체해서 사용

참고1)
※ 연관관계 : 어떤역할 수행 (long)   -    실선이나 화살표 
※ 의존관계 :              (short)  -    점선 화살표
※ 실체화관계 : 인터페이스와 구현클래스 -   속이빈 화살표 점선  -  can do this  
※ 일반화관계 : 상속  -                  속이빈 화살표 실선  -   is a 
※ 집합관계   :   합성관계 - 생성자에서 new - 속이찬 다이아몬드 ◆
                       집약관계 - 생성자에서 참조   -        ◇


참조2)      연관관계          의존관계
<<Driver>> ――――――> <<Car>> -----> <<GasPump>>

class Driver{
   private Car car; // 멤버변수  - 연관관계
   public void fillGas(GasPump p){
      p.getGas(amount);  // 연산의 인자(참조값)
   }
}


◎4. 기능흐름도 OR 시퀀스다이어그램
◎5. 확장가능성